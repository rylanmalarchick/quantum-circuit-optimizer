# OpenCode Context

**Project:** quantum-circuit-optimizer
**Chunks loaded:** 22
**Approximate tokens:** 20206

---

## Source: SCOPE_OF_WORK.md
*Current sprint scope and objectives*

### Sprint 1B: DAG IR (lines 1-113)
# Quantum Circuit Optimizer: Scope of Work

**Project:** quantum-circuit-optimizer  
**Author:** Rylan Malarchick  
**Created:** December 2025  
**Status:** Sprint 2 Complete

---

## Executive Summary

Build a production-quality quantum circuit compiler in C++17 that:
1. Parses OpenQASM 3.0 circuit descriptions
2. Represents circuits as a DAG-based intermediate representation
3. Optimizes circuits through multiple transformation passes
4. Performs topology-aware qubit routing with SWAP insertion

The project follows research-code-principles with comprehensive testing, CI/CD, and documentation.

---

## Sprint Overview

| Sprint | Focus | Duration | Status |
|--------|-------|----------|--------|
| **1A** | Foundation (Gate, Circuit, Build, CI) | 3-5 sessions | Complete |
| **1B** | DAG IR for Optimization | 2-3 sessions | Complete |
| **2** | OpenQASM 3.0 Parser | 3-4 sessions | Complete |
| **3** | Optimization Passes | 4-5 sessions | Planned |
| **4** | Qubit Routing | 4-5 sessions | Planned |
| **5** | Polish & Documentation | 2-3 sessions | Planned |

---

## Sprint 1A: Foundation

**Goal:** Working build, basic IR, first tests passing, CI/CD running  
**Exit Criteria:** `cmake --build build && ctest` passes with >=10 unit tests

### Deliverables

| Component | Description | Tests |
|-----------|-------------|-------|
| `Types.hpp` | Common type aliases (QubitIndex, Angle), constants (MAX_QUBITS) | - |
| `Gate.hpp` | Gate representation with factory methods, validation, operators | 26 |
| `Qubit.hpp` | Qubit utilities and type definitions | - |
| `Circuit.hpp` | Circuit container with iteration, depth calculation, metrics | 24 |
| `CMakeLists.txt` | Build system with warnings, GoogleTest, CTest | - |
| `ci.yml` | GitHub Actions CI pipeline | - |

### Key Design Decisions

- **Factory methods**: `Gate::h(qubit)`, `Gate::cnot(control, target)`, `Gate::rz(qubit, angle)`
- **Validation at boundaries**: All public methods validate inputs, throw descriptive exceptions
- **RAII**: Smart pointers for ownership, no raw new/delete
- **Zero warnings**: `-Wall -Wextra -Wpedantic -Werror` in CI

### Acceptance Criteria

- [x] `cmake -B build` succeeds
- [x] `cmake --build build` succeeds with zero warnings
- [x] `ctest` runs 50 tests, all pass
- [x] CI pipeline passes on GitHub
- [x] All source files have SPDX headers

---

## Sprint 1B: DAG IR

**Goal:** DAG-based intermediate representation for circuit optimization  
**Exit Criteria:** DAG construction, topological traversal, and node manipulation work with >=20 tests

### Deliverables

| Component | Description | Tests |
|-----------|-------------|-------|
| `DAG.hpp` | DAG class with node management, topological sort, traversal | 54 |
| `DAGNode` | Node wrapper containing Gate, predecessor/successor edges | - |

### Key Design Decisions

- **Ownership model**: DAG owns nodes via `std::unique_ptr<DAGNode>`, edges are raw pointers (non-owning)
- **Topological sort**: Kahn's algorithm with citation (Kahn 1962)
- **Traversal**: Both forward (topological) and reverse iteration support
- **Thread safety**: Not thread-safe (documented)

### API Surface

```cpp
// DAGNode - wrapper around Gate with graph edges
class DAGNode {
public:
    explicit DAGNode(Gate gate);
    
    [[nodiscard]] const Gate& gate() const noexcept;
    [[nodiscard]] const std::vector<DAGNode*>& predecessors() const noexcept;
    [[nodiscard]] const std::vector<DAGNode*>& successors() const noexcept;
    
    void addPredecessor(DAGNode* node);
    void addSuccessor(DAGNode* node);
    void removePredecessor(DAGNode* node);
    void removeSuccessor(DAGNode* node);
};

// DAG - directed acyclic graph of quantum gates
class DAG {
public:
    explicit DAG(size_t numQubits);
    
    // Node management
    DAGNode* addNode(Gate gate);
    void removeNode(DAGNode* node);
    

### Sprint 3: Optimization Passes (lines 85-222)
- **Thread safety**: Not thread-safe (documented)

### API Surface

```cpp
// DAGNode - wrapper around Gate with graph edges
class DAGNode {
public:
    explicit DAGNode(Gate gate);
    
    [[nodiscard]] const Gate& gate() const noexcept;
    [[nodiscard]] const std::vector<DAGNode*>& predecessors() const noexcept;
    [[nodiscard]] const std::vector<DAGNode*>& successors() const noexcept;
    
    void addPredecessor(DAGNode* node);
    void addSuccessor(DAGNode* node);
    void removePredecessor(DAGNode* node);
    void removeSuccessor(DAGNode* node);
};

// DAG - directed acyclic graph of quantum gates
class DAG {
public:
    explicit DAG(size_t numQubits);
    
    // Node management
    DAGNode* addNode(Gate gate);
    void removeNode(DAGNode* node);
    
    // Graph queries
    [[nodiscard]] size_t numNodes() const noexcept;
    [[nodiscard]] size_t numQubits() const noexcept;
    [[nodiscard]] bool empty() const noexcept;
    
    // Traversal
    [[nodiscard]] std::vector<DAGNode*> topologicalOrder() const;
    [[nodiscard]] std::vector<DAGNode*> nodesOnQubit(size_t qubit) const;
    
    // Conversion
    [[nodiscard]] Circuit toCircuit() const;
    static DAG fromCircuit(const Circuit& circuit);
};
```

### Acceptance Criteria

- [x] DAG construction from Circuit works correctly
- [x] Topological sort produces valid ordering
- [x] Node removal maintains graph consistency
- [x] 54 tests pass with zero warnings
- [x] Kahn's algorithm properly cited in source

---

## Sprint 2: OpenQASM 3.0 Parser

**Goal:** Parse OpenQASM 3.0 files into Circuit/DAG representation  
**Exit Criteria:** Parser handles core QASM constructs with >=30 tests

### Deliverables

| Component | Description | Tests |
|-----------|-------------|-------|
| `Lexer.hpp` | Tokenizer for OpenQASM 3.0 | 58 |
| `Parser.hpp` | Recursive descent parser producing Circuit | 51 |
| `Token.hpp` | Token types and Token class | - |
| `QASMError.hpp` | Error types with line/column information | - |

### Supported Constructs

```qasm
// Version declaration
OPENQASM 3.0;

// Quantum register declaration
qubit[4] q;

// Classical register declaration (optional)
bit[4] c;

// Gate applications
h q[0];
cx q[0], q[1];
rz(pi/4) q[2];

// Measurement
c[0] = measure q[0];
```

### Key Design Decisions

- **Recursive descent**: Simple, readable, sufficient for QASM subset
- **Error recovery**: Continue parsing after errors to report multiple issues
- **Line/column tracking**: All errors include source location
- **Extensibility**: Parser architecture allows adding constructs incrementally

### API Surface

```cpp
class Parser {
public:
    explicit Parser(std::string_view source);
    
    [[nodiscard]] Circuit parse();
    [[nodiscard]] DAG parseToDAG();
    
    [[nodiscard]] bool hasErrors() const noexcept;
    [[nodiscard]] const std::vector<QASMError>& errors() const noexcept;
};

// Convenience function
[[nodiscard]] Circuit parseQASM(std::string_view source);
[[nodiscard]] Circuit parseQASMFile(const std::filesystem::path& path);
```

### Acceptance Criteria

- [x] Lexer tokenizes all QASM 3.0 tokens correctly
- [x] Parser handles qubit declarations
- [x] Parser handles standard gates (h, x, y, z, cx, cz, rx, ry, rz)
- [x] Parser reports errors with line/column
- [x] Round-trip: parse -> Circuit -> emit matches input semantics
- [x] >=30 tests pass (109 new tests, 213 total)

---

## Sprint 3: Optimization Passes

**Goal:** Implement circuit optimization passes using DAG IR  
**Exit Criteria:** Passes demonstrably reduce circuit metrics with >=40 tests

### Deliverables

| Component | Description | Tests |
|-----------|-------------|-------|
| `Pass.hpp` | Base class for optimization passes | - |
| `PassManager.hpp` | Pipeline for running multiple passes | ~10 |
| `CancellationPass.hpp` | Cancel adjacent inverse gates (XX, HH, etc.) | ~10 |

### Sprint 4: Qubit Routing (lines 203-327)
- [x] Parser handles qubit declarations
- [x] Parser handles standard gates (h, x, y, z, cx, cz, rx, ry, rz)
- [x] Parser reports errors with line/column
- [x] Round-trip: parse -> Circuit -> emit matches input semantics
- [x] >=30 tests pass (109 new tests, 213 total)

---

## Sprint 3: Optimization Passes

**Goal:** Implement circuit optimization passes using DAG IR  
**Exit Criteria:** Passes demonstrably reduce circuit metrics with >=40 tests

### Deliverables

| Component | Description | Tests |
|-----------|-------------|-------|
| `Pass.hpp` | Base class for optimization passes | - |
| `PassManager.hpp` | Pipeline for running multiple passes | ~10 |
| `CancellationPass.hpp` | Cancel adjacent inverse gates (XX, HH, etc.) | ~10 |
| `CommutationPass.hpp` | Reorder commuting gates for optimization | ~10 |
| `RotationMergePass.hpp` | Merge adjacent rotation gates (Rz(a)Rz(b) = Rz(a+b)) | ~10 |
| `IdentityEliminationPass.hpp` | Remove identity gates (Rz(0), etc.) | ~5 |

### Pass Architecture

```cpp
// Base class for all passes
class Pass {
public:
    virtual ~Pass() = default;
    
    [[nodiscard]] virtual std::string name() const = 0;
    virtual void run(DAG& dag) = 0;
    
    // Statistics
    [[nodiscard]] size_t gatesRemoved() const noexcept;
    [[nodiscard]] size_t gatesAdded() const noexcept;
};

// Pipeline manager
class PassManager {
public:
    void addPass(std::unique_ptr<Pass> pass);
    
    void run(DAG& dag);
    void run(Circuit& circuit);  // Converts to DAG internally
    
    [[nodiscard]] PassStatistics statistics() const;
};
```

### Optimization Strategies

| Pass | Strategy | Expected Reduction |
|------|----------|-------------------|
| **Cancellation** | Find adjacent inverse pairs on same qubits | 5-15% |
| **Commutation** | Move gates through commuting neighbors to enable cancellation | 2-5% |
| **Rotation Merge** | Combine Rz(a)Rz(b) -> Rz(a+b) | 5-10% |
| **Identity Elimination** | Remove Rz(0), etc. | 1-3% |

### Commutation Rules

```
[H, Z] = 0  (up to global phase)
[CNOT, Z_control] = 0
[CNOT, X_target] = 0
[Rz(a), Rz(b)] = 0
[CZ, Z_either] = 0
```

### Acceptance Criteria

- [ ] PassManager runs passes in sequence
- [ ] CancellationPass removes inverse pairs
- [ ] RotationMergePass combines rotations correctly
- [ ] Passes preserve circuit semantics (validated by simulation)
- [ ] >=40 tests pass

---

## Sprint 4: Qubit Routing

**Goal:** Map logical qubits to physical topology with SWAP insertion  
**Exit Criteria:** Router produces valid physical circuits for various topologies with >=30 tests

### Deliverables

| Component | Description | Tests |
|-----------|-------------|-------|
| `Topology.hpp` | Graph representation of qubit connectivity | ~10 |
| `Router.hpp` | Base class for routing algorithms | - |
| `SabreRouter.hpp` | SABRE routing algorithm implementation | ~15 |
| `RoutingResult.hpp` | Result container with mapping and statistics | - |
| `topologies/` | Predefined topologies (linear, grid, heavy-hex) | ~5 |

### Topology API

```cpp
class Topology {
public:
    explicit Topology(size_t numQubits);
    
    void addEdge(size_t q1, size_t q2);
    [[nodiscard]] bool connected(size_t q1, size_t q2) const;
    [[nodiscard]] size_t distance(size_t q1, size_t q2) const;
    [[nodiscard]] std::vector<size_t> neighbors(size_t qubit) const;
    
    // Predefined topologies
    static Topology linear(size_t n);
    static Topology grid(size_t rows, size_t cols);
    static Topology heavyHex(size_t distance);
};
```

### Router API

```cpp
struct RoutingResult {
    Circuit routed_circuit;
    std::vector<size_t> initial_mapping;  // logical -> physical
    size_t swaps_inserted;
    size_t depth_overhead;
};


### Architecture Overview (lines 298-433)

### Topology API

```cpp
class Topology {
public:
    explicit Topology(size_t numQubits);
    
    void addEdge(size_t q1, size_t q2);
    [[nodiscard]] bool connected(size_t q1, size_t q2) const;
    [[nodiscard]] size_t distance(size_t q1, size_t q2) const;
    [[nodiscard]] std::vector<size_t> neighbors(size_t qubit) const;
    
    // Predefined topologies
    static Topology linear(size_t n);
    static Topology grid(size_t rows, size_t cols);
    static Topology heavyHex(size_t distance);
};
```

### Router API

```cpp
struct RoutingResult {
    Circuit routed_circuit;
    std::vector<size_t> initial_mapping;  // logical -> physical
    size_t swaps_inserted;
    size_t depth_overhead;
};

class Router {
public:
    virtual ~Router() = default;
    
    [[nodiscard]] virtual RoutingResult route(
        const Circuit& circuit,
        const Topology& topology
    ) = 0;
};

// SABRE implementation
class SabreRouter : public Router {
public:
    SabreRouter(size_t lookahead = 20, size_t decay = 0.001);
    
    [[nodiscard]] RoutingResult route(
        const Circuit& circuit,
        const Topology& topology
    ) override;
};
```

### SABRE Algorithm

Reference: Li et al., "Tackling the Qubit Mapping Problem for NISQ-Era Quantum Devices" (2019)

1. **Initial mapping**: Heuristic based on gate frequency
2. **Forward pass**: Process gates, insert SWAPs when needed
3. **Backward pass**: Refine mapping by processing in reverse
4. **Lookahead**: Consider future gates when choosing SWAPs

### Acceptance Criteria

- [ ] Topology correctly represents device connectivity
- [ ] SabreRouter produces valid physical circuits
- [ ] All two-qubit gates in output are on connected qubits
- [ ] Router works on linear, grid, and heavy-hex topologies
- [ ] SWAP overhead is reasonable (< 3x gate increase for typical circuits)
- [ ] >=30 tests pass

---

## Sprint 5: Polish & Documentation

**Goal:** Production-ready release with comprehensive documentation  
**Exit Criteria:** All documentation complete, benchmarks run, release tagged

### Deliverables

| Component | Description |
|-----------|-------------|
| API Documentation | Doxygen-generated docs for all public APIs |
| User Guide | Tutorial-style guide with examples |
| Benchmarks | Performance benchmarks with standard circuits |
| Examples | Example programs demonstrating usage |
| Release | Tagged v1.0.0 release with changelog |

### Documentation Structure

```
docs/
├── index.md                 # Overview and quick start
├── building.md              # Build instructions
├── tutorial/
│   ├── 01-circuits.md       # Working with circuits
│   ├── 02-parsing.md        # Parsing OpenQASM
│   ├── 03-optimization.md   # Optimization passes
│   └── 04-routing.md        # Qubit routing
├── api/                     # Generated Doxygen docs
├── architecture.md          # Design decisions
└── benchmarks.md            # Performance results
```

### Benchmark Suite

| Circuit | Qubits | Gates | Purpose |
|---------|--------|-------|---------|
| QFT | 4-20 | O(n^2) | Scalability |
| Random | 10, 20, 50 | 100-1000 | Typical workload |
| Adder | 8-32 | O(n) | Practical circuit |
| QAOA | 10-20 | O(n^2) | Variational |

### Acceptance Criteria

- [ ] All public APIs have Doxygen documentation
- [ ] User guide covers all major features
- [ ] Examples compile and run
- [ ] Benchmarks produce reproducible results
- [ ] CHANGELOG.md documents all changes
- [ ] README.md updated with final status
- [ ] GitHub release tagged v1.0.0

---

## Architecture Overview

```
quantum-circuit-optimizer/
├── include/
│   ├── ir/
│   │   ├── Types.hpp           # Type aliases, constants
│   │   ├── Gate.hpp            # Gate representation
│   │   ├── Qubit.hpp           # Qubit utilities
│   │   ├── Circuit.hpp         # Circuit container
│   │   └── DAG.hpp             # DAG IR
│   ├── parser/

### Changelog (lines 408-532)
| QAOA | 10-20 | O(n^2) | Variational |

### Acceptance Criteria

- [ ] All public APIs have Doxygen documentation
- [ ] User guide covers all major features
- [ ] Examples compile and run
- [ ] Benchmarks produce reproducible results
- [ ] CHANGELOG.md documents all changes
- [ ] README.md updated with final status
- [ ] GitHub release tagged v1.0.0

---

## Architecture Overview

```
quantum-circuit-optimizer/
├── include/
│   ├── ir/
│   │   ├── Types.hpp           # Type aliases, constants
│   │   ├── Gate.hpp            # Gate representation
│   │   ├── Qubit.hpp           # Qubit utilities
│   │   ├── Circuit.hpp         # Circuit container
│   │   └── DAG.hpp             # DAG IR
│   ├── parser/
│   │   ├── Lexer.hpp           # Tokenizer
│   │   ├── Parser.hpp          # QASM parser
│   │   └── QASMError.hpp       # Error types
│   ├── passes/
│   │   ├── Pass.hpp            # Base class
│   │   ├── PassManager.hpp     # Pipeline
│   │   ├── CancellationPass.hpp
│   │   ├── CommutationPass.hpp
│   │   ├── RotationMergePass.hpp
│   │   └── IdentityEliminationPass.hpp
│   └── routing/
│       ├── Topology.hpp        # Device topology
│       ├── Router.hpp          # Base class
│       └── SabreRouter.hpp     # SABRE implementation
├── src/
│   ├── ir/
│   ├── parser/
│   ├── passes/
│   ├── routing/
│   └── main.cpp
├── tests/
│   ├── ir/
│   ├── parser/
│   ├── passes/
│   └── routing/
├── benchmarks/
├── examples/
├── docs/
├── CMakeLists.txt
├── README.md
├── SCOPE_OF_WORK.md            # This file
├── CHANGELOG.md
└── LICENSE
```

---

## Test Coverage Goals

| Sprint | Component | Target Tests | Coverage |
|--------|-----------|--------------|----------|
| 1A | Gate, Circuit | 50 | 90% |
| 1B | DAG | 54 | 90% |
| 2 | Parser | 109 | 85% |
| 3 | Passes | 40 | 85% |
| 4 | Routing | 30 | 80% |
| **Total** | - | **283** | **85%** |

---

## Dependencies

| Dependency | Version | Purpose |
|------------|---------|---------|
| CMake | >= 3.18 | Build system |
| C++ Compiler | C++17 | GCC 9+, Clang 10+ |
| GoogleTest | v1.14.0 | Testing framework |

**No external runtime dependencies.** All functionality is self-contained.

---

## Risk Register

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| QASM 3.0 complexity | Medium | High | Support subset, add features incrementally |
| SABRE performance | Low | Medium | Profile early, optimize critical paths |
| Scope creep | Medium | Medium | Stick to sprint boundaries, defer features |
| Test coverage gaps | Low | High | Enforce coverage in CI |

---

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Test coverage | >= 85% | gcov/lcov |
| Build time | < 30s | CI timing |
| Optimization reduction | >= 15% | Benchmark suite |
| Routing overhead | < 3x SWAP increase | Benchmark suite |
| Documentation | 100% public API | Doxygen warnings = 0 |

---

## References

1. Nielsen & Chuang, "Quantum Computation and Quantum Information" (2010)
2. Kahn, A.B., "Topological sorting of large networks", Comm. ACM 5(11):558-562 (1962)
3. Li et al., "Tackling the Qubit Mapping Problem for NISQ-Era Quantum Devices" (2019)
4. OpenQASM 3.0 Specification: https://openqasm.com/

---

## Changelog

| Date | Sprint | Changes |
|------|--------|---------|
| 2025-12 | 1A | Foundation complete: Gate, Circuit, 50 tests |

### Changelog (lines 513-540)
| Optimization reduction | >= 15% | Benchmark suite |
| Routing overhead | < 3x SWAP increase | Benchmark suite |
| Documentation | 100% public API | Doxygen warnings = 0 |

---

## References

1. Nielsen & Chuang, "Quantum Computation and Quantum Information" (2010)
2. Kahn, A.B., "Topological sorting of large networks", Comm. ACM 5(11):558-562 (1962)
3. Li et al., "Tackling the Qubit Mapping Problem for NISQ-Era Quantum Devices" (2019)
4. OpenQASM 3.0 Specification: https://openqasm.com/

---

## Changelog

| Date | Sprint | Changes |
|------|--------|---------|
| 2025-12 | 1A | Foundation complete: Gate, Circuit, 50 tests |
| 2025-12 | 1B | DAG IR complete: DAGNode, DAG, 54 tests, 104 total |
| 2025-12 | 2 | Parser complete: Token, Lexer, Parser, QASMError, 109 tests, 213 total |

---

**License:** MIT  
**Author:** Rylan Malarchick (rylan1012@gmail.com)


## Source: prompting-research-code.md
*Prompting patterns for research code*

### Pattern 3: Enforcing Validation (System Prompt) (lines 1-133)
# Prompting Research Code: How to Pair with Claude/ChatGPT

**Author:** Rylan Malarchick  
**Version:** 1.0  
**Last Updated:** December 2025

This guide synthesizes:
1. **Research Code Principles** (this repo): Why good code matters
2. **Prompt Engineering Best Practices** (Google, Feb 2025): How to get AI to write better code

Together: A complete system for AI-assisted research software development.

---

## The Problem

When you ask Claude "write a rotation gate," you get code that compiles. But:
- No validation of rotation angle
- No tests against known matrices
- No citation of Nielsen & Chuang
- No edge case handling

**Why?** Because Claude optimizes for "code that runs," not "code that's correct."

---

## Mapping Prompting Techniques to Research Principles

| Principle | Technique | Use Case |
|-----------|-----------|----------|
| **Correctness First** | Few-Shot with examples | Provide correct examples before asking |
| **Specification Before Code** | Chain of Thought (CoT) | "Think step by step: what edge cases exist?" |
| **Fail Fast** | System Prompt + Role | Set role: "Write research code that validates all inputs" |
| **Simplicity** | Few-Shot role examples | Show short functions, ask for same pattern |
| **Infrastructure** | CoT for test-first | "Write tests first, then code" |

---

## Pattern 1: Test-First Code (Chain of Thought)

**Bad Prompt:**
```
Write a function to compute quantum fidelity between two unitaries.
```

**Good Prompt:**
```
You are implementing a quantum fidelity function following research-code-principles.

Think step by step:
1. What is the mathematical definition? (Cite source)
2. What inputs must be validated? (Shapes, unitarity, NaN)
3. What edge cases must tests cover? (Identity, single qubit, max size)
4. What physical constraints must hold? (F in [0, 1])
5. What numerical stability issues exist?

After thinking:
1. Write test cases (at least 6: happy path + 5 edge cases)
2. Then the implementation
3. Then validation code

Cite Nielsen & Chuang for the definition.
```

**Why it works:** CoT forces the model to reason about correctness before writing code. The explicit request for citations and edge cases prevents the "optimistic code" failure mode.

---

## Pattern 2: Correctness Through Examples (Few-Shot)

**Bad Prompt:**
```
Implement a Pauli X gate.
```

**Good Prompt:**
```
Here are examples of correct gate implementations:

Example 1: Pauli Z Gate
```python
def z_gate() -> np.ndarray:
    """Pauli Z gate: |0⟩ → |0⟩, |1⟩ → -|1⟩.
    
    Matrix representation from Nielsen & Chuang, Eq. 4.2:
    Z = [[1, 0], [0, -1]]
    
    Returns:
        2x2 unitary matrix.
    """
    return np.array([[1, 0], [0, -1]], dtype=complex)

# Test: Z² = I
assert np.allclose(z_gate() @ z_gate(), np.eye(2))
```

Example 2: Hadamard Gate
```python
def h_gate() -> np.ndarray:
    """Hadamard gate: creates equal superposition.
    
    Matrix representation from Nielsen & Chuang, Eq. 4.3:
    H = (1/√2) [[1, 1], [1, -1]]
    
    Returns:
        2x2 unitary matrix.
    """
    return np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)

# Test: H² = I
assert np.allclose(h_gate() @ h_gate(), np.eye(2))
```

Now implement Pauli X gate following the same pattern:
1. Definition comment with source citation
2. Test that X² = I
3. Validate against ground truth matrix
```

**Why it works:** Few-shot provides a concrete template. The model learns the pattern (docstring → citation → matrix → test) and applies it consistently.

---

## Pattern 3: Enforcing Validation (System Prompt)

**Bad Prompt:**
```
Write a circuit optimization function.
```

**Good Prompt:**
```
You are a research software engineer implementing quantum circuit optimization.

### Quick Templates (lines 104-261)
    
    Returns:
        2x2 unitary matrix.
    """
    return np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)

# Test: H² = I
assert np.allclose(h_gate() @ h_gate(), np.eye(2))
```

Now implement Pauli X gate following the same pattern:
1. Definition comment with source citation
2. Test that X² = I
3. Validate against ground truth matrix
```

**Why it works:** Few-shot provides a concrete template. The model learns the pattern (docstring → citation → matrix → test) and applies it consistently.

---

## Pattern 3: Enforcing Validation (System Prompt)

**Bad Prompt:**
```
Write a circuit optimization function.
```

**Good Prompt:**
```
You are a research software engineer implementing quantum circuit optimization.
Every function must validate all inputs at boundaries and fail fast.

Task: Write an optimization function that accepts:
- Input circuit (must be non-null, valid gates)
- Number of iterations (must be > 0)
- Tolerance (must be in (0, 1))

Requirements:
1. Validate all inputs immediately, throw descriptive exceptions
2. Include at least 3 test cases for invalid inputs
3. Error messages must include: what went wrong, what was expected, where

Example of correct validation:
```python
if tolerance <= 0.0 or tolerance >= 1.0:
    raise ValueError(
        f"Tolerance must be in (0, 1), got {tolerance}"
    )
```

Now implement the function with full validation.
```

**Why it works:** The system prompt establishes the "fail fast" expectation. The concrete example shows the error message format. The explicit requirement for invalid input tests prevents the "optimistic code" failure.

---

## Pattern 4: Simplicity Through Constraints

**Bad Prompt:**
```
Write an optimization loop.
```

**Good Prompt:**
```
Functions must be ≤50 lines (Python), ≤60 lines (C++).

Example of correct breakdown:
```python
def optimize_circuit(circuit, max_iterations):
    """High-level optimization loop."""
    state = _initialize_state(circuit)
    
    for _ in range(max_iterations):
        state = _update_state(state, circuit)
        if _converged(state):
            break
    
    return _finalize_results(state)

def _initialize_state(circuit):
    """Set up initial optimization state."""
    # 10 lines

def _update_state(state, circuit):
    """Single iteration of optimization."""
    # 15 lines
```

Now write an optimization function following this pattern.
Break complex logic into helper functions. Each function does ONE thing.
```

**Why it works:** The line limit constraint is explicit. The example shows the decomposition pattern. The model learns to break down rather than monolith.

---

## Temperature Settings

| Task | Temperature | Rationale |
|------|-------------|-----------|
| **Implementation** | 0.0-0.1 | Deterministic, correct code |
| **Test generation** | 0.1-0.2 | Slight variation for edge cases |
| **Edge case exploration** | 0.3-0.5 | Creative thinking about failures |
| **Never for research code** | > 0.8 | Too random, introduces errors |

---

## Quick Templates

### Template 1: Test-First Implementation

```
You are implementing [function] for research software.

Think step by step:
1. What is the spec? (cite source)
2. What edge cases exist?
3. What physical constraints apply?

Then:
1. Write ≥5 test cases (happy path + edge cases)
2. Implement the function
3. Show validation against ground truth

Temperature: 0.1
```

### Template 2: Validation-Heavy Code

```
Every input must be validated at function boundaries.

Example:
```python
if condition_invalid:
    raise ValueError(
        f"Parameter X must satisfy constraint, got {value}"
    )
```

Now implement [function] with comprehensive input validation.
Fail fast. Include ≥3 test cases for invalid inputs.

Temperature: 0.1
```

### Template 3: Simplicity-First Code

```
Functions must be ≤50 lines (Python), ≤60 lines (C++).
Each function does ONE thing.

If [task] is complex, break into:
1. _helper1: [focused subtask]
2. _helper2: [focused subtask]
3. main_function: orchestrates helpers

### See Also (lines 227-331)
2. Implement the function
3. Show validation against ground truth

Temperature: 0.1
```

### Template 2: Validation-Heavy Code

```
Every input must be validated at function boundaries.

Example:
```python
if condition_invalid:
    raise ValueError(
        f"Parameter X must satisfy constraint, got {value}"
    )
```

Now implement [function] with comprehensive input validation.
Fail fast. Include ≥3 test cases for invalid inputs.

Temperature: 0.1
```

### Template 3: Simplicity-First Code

```
Functions must be ≤50 lines (Python), ≤60 lines (C++).
Each function does ONE thing.

If [task] is complex, break into:
1. _helper1: [focused subtask]
2. _helper2: [focused subtask]
3. main_function: orchestrates helpers

Now implement [task] following this pattern.

Temperature: 0.1
```

### Template 4: Physics Validation

```
You are implementing [physical calculation].

Physical constraints that MUST hold:
- [constraint 1, e.g., unitarity: U†U = I]
- [constraint 2, e.g., normalization: sum to 1]
- [constraint 3, e.g., bounds: value in [0, 1]]

Include validation code that checks these constraints.
Include tests that verify constraint violations are caught.

Cite source for the mathematical definition.

Temperature: 0.1
```

---

## Common Issues and Fixes

| Problem | Symptom | Fix |
|---------|---------|-----|
| Agent skips tests | "Here's the implementation..." | Use CoT: "Write tests first. Think step by step." |
| No error handling | Assumes valid input | System prompt: "Every function validates inputs" |
| Magic numbers | `tolerance = 1e-10` | Few-shot with constants defined and commented |
| Missing citations | Algorithm with no source | Few-shot: `# From Nielsen & Chuang, Eq 2.X` |
| Functions too long | 100+ lines | Constraint: "≤50 lines, break into helpers" |
| Numerical issues | Subtracts nearly-equal numbers | CoT: "What numerical stability issues exist?" |
| No edge cases | Only happy path tested | Explicit: "Test empty, single, max, zero, invalid" |

---

## Session Log Template

Track your prompting experiments:

```markdown
## Session: [Date] [Task]

### Attempt 1
- **Temperature:** 0.1
- **Prompt:** [exact prompt]
- **Result:** [what worked/didn't]
- **Issues:** [hallucinations, missing validation, etc.]

### Attempt 2
- **Temperature:** 0.1  
- **Prompt:** [refined]
- **Result:** [better? worse?]

### Takeaway
[What made it better]
```

---

## See Also

- `examples/quantum-gate-example/prompting-log.md` — Real prompting session
- `agent-coding-context.md` — Paste into AI for coding sessions
- `research-code-principles.md` — The philosophy behind these patterns


## Source: quantum_circuit_optimizer_guide.md
*Architecture and design guide*

### Phase 1: Project Setup & Core IR (Weeks 1-2) (lines 1-120)
# Quantum Circuit Optimizer Project Guide
## C++ Compiler Infrastructure for Quantum Circuits

**Goal:** Build a production-quality quantum circuit compiler in C++ that parses OpenQASM 3.0, optimizes circuits through multiple passes, and performs topology-aware qubit routing.

**Timeline:** Multi-month project (not a weekend hack)

**Why This Matters:**
- Direct alignment with quantum compiler PhD research
- Demonstrates you can build real compiler infrastructure, not just use existing tools
- Bridges your LLVM pass experience with quantum computing domain
- Separate portfolio piece from QubitPulseOpt (frontend vs backend)

---

## Project Overview

### The Full Stack

```
OpenQASM 3.0 Input
       ↓
┌──────────────────┐
│     Parser       │  ← Lexer + AST construction
└──────────────────┘
       ↓
┌──────────────────┐
│   Circuit IR     │  ← DAG-based intermediate representation
└──────────────────┘
       ↓
┌──────────────────┐
│ Optimization     │  ← Gate cancellation, commutation, merging
│    Passes        │
└──────────────────┘
       ↓
┌──────────────────┐
│  Qubit Routing   │  ← Logical → Physical mapping + SWAP insertion
└──────────────────┘
       ↓
┌──────────────────┐
│    Output        │  ← Optimized OpenQASM, stats, visualization
└──────────────────┘
```

---

## Phase 1: Project Setup & Core IR (Weeks 1-2)

### Goals
- Set up C++ project with CMake
- Define the circuit intermediate representation (DAG-based)
- Basic data structures for gates, qubits, circuits

### Deliverables

**Project Structure:**
```
quantum-circuit-optimizer/
├── CMakeLists.txt
├── LICENSE                    # MIT license
├── README.md
├── .gitignore
├── include/
│   ├── ir/
│   │   ├── Gate.hpp           # Gate class + GateType enum
│   │   ├── Qubit.hpp          # Qubit representation
│   │   ├── Circuit.hpp        # Circuit container
│   │   ├── DAG.hpp            # DAG IR for optimization
│   │   └── Types.hpp          # Common typedefs, constants
│   ├── parser/
│   │   ├── Token.hpp          # Token types for lexer
│   │   ├── Lexer.hpp          # Tokenizer
│   │   ├── AST.hpp            # Abstract syntax tree nodes
│   │   └── Parser.hpp         # Recursive descent parser
│   ├── passes/
│   │   ├── Pass.hpp           # Base pass interface
│   │   ├── PassManager.hpp    # Pass orchestration
│   │   ├── CancellationPass.hpp
│   │   ├── CommutationPass.hpp
│   │   └── MergingPass.hpp
│   └── routing/
│       ├── CouplingMap.hpp    # Hardware topology
│       └── Router.hpp         # SWAP insertion
├── src/
│   ├── ir/
│   │   ├── Gate.cpp
│   │   ├── Circuit.cpp
│   │   └── DAG.cpp
│   ├── parser/
│   │   ├── Lexer.cpp
│   │   └── Parser.cpp
│   ├── passes/
│   │   ├── PassManager.cpp
│   │   ├── CancellationPass.cpp
│   │   ├── CommutationPass.cpp
│   │   └── MergingPass.cpp
│   ├── routing/
│   │   ├── CouplingMap.cpp
│   │   └── Router.cpp
│   └── main.cpp
├── tests/
│   ├── ir/
│   │   ├── test_gate.cpp
│   │   ├── test_circuit.cpp
│   │   └── test_dag.cpp
│   ├── parser/
│   │   ├── test_lexer.cpp
│   │   └── test_parser.cpp
│   ├── passes/
│   │   ├── test_cancellation.cpp
│   │   ├── test_commutation.cpp
│   │   └── test_merging.cpp
│   ├── routing/
│   │   ├── test_coupling_map.cpp
│   │   └── test_router.cpp
│   ├── integration/
│   │   └── test_full_pipeline.cpp
│   └── circuits/               # Test QASM files
│       ├── bell.qasm
│       ├── ghz.qasm

### Phase 3: Optimization Passes (Weeks 6-9) (lines 99-255)
│   │   └── Router.cpp
│   └── main.cpp
├── tests/
│   ├── ir/
│   │   ├── test_gate.cpp
│   │   ├── test_circuit.cpp
│   │   └── test_dag.cpp
│   ├── parser/
│   │   ├── test_lexer.cpp
│   │   └── test_parser.cpp
│   ├── passes/
│   │   ├── test_cancellation.cpp
│   │   ├── test_commutation.cpp
│   │   └── test_merging.cpp
│   ├── routing/
│   │   ├── test_coupling_map.cpp
│   │   └── test_router.cpp
│   ├── integration/
│   │   └── test_full_pipeline.cpp
│   └── circuits/               # Test QASM files
│       ├── bell.qasm
│       ├── ghz.qasm
│       └── random_*.qasm
└── benchmarks/
    ├── bench_parser.cpp
    ├── bench_passes.cpp
    └── bench_routing.cpp
```

### Core IR Design

**Gate Representation:**
- Gate type (X, Y, Z, H, CNOT, Rz, etc.)
- Target qubit(s)
- Parameters (for parameterized gates like Rz(θ))
- Unique ID for DAG node

**DAG Structure:**
- Nodes = gates
- Edges = dependencies (qubit wire connections)
- Enables topological traversal for optimization

### Key Concepts to Implement
- [ ] Gate class with type enum and qubit references
- [ ] Circuit class holding qubit register and gate list
- [ ] DAG class with adjacency list representation
- [ ] Basic circuit construction API

---

## Phase 2: OpenQASM 3.0 Parser (Weeks 3-5)

### Goals
- Lexer to tokenize OpenQASM 3.0 input
- Recursive descent parser to build AST
- AST → Circuit IR conversion

### OpenQASM 3.0 Subset to Support

Start with a practical subset:
```qasm
OPENQASM 3.0;
include "stdgates.inc";

qubit[4] q;
bit[4] c;

h q[0];
cx q[0], q[1];
rz(0.5) q[1];
cx q[1], q[2];
measure q -> c;
```

### Features to Parse
- [ ] Version declaration
- [ ] Qubit/bit register declarations
- [ ] Standard gates (h, x, y, z, cx, cz, rx, ry, rz, etc.)
- [ ] Gate parameters (angles)
- [ ] Measurement operations
- [ ] Comments

### Stretch (Later)
- Custom gate definitions
- Classical control flow
- Subroutines

### Implementation Approach

**Lexer:**
- Hand-written lexer (not flex/bison - better learning experience)
- Token types: KEYWORD, IDENTIFIER, NUMBER, OPERATOR, etc.

**Parser:**
- Recursive descent parser
- One function per grammar rule
- Build AST nodes during parsing

**Error Handling:**
- Line/column tracking
- Meaningful error messages

---

## Phase 3: Optimization Passes (Weeks 6-9)

### Goals
- Pass manager infrastructure (like LLVM)
- Gate cancellation pass
- Gate commutation pass
- Gate merging pass

### Pass Infrastructure

**Base Pass Class (with proper interface design):**
```cpp
// SPDX-License-Identifier: MIT
// Copyright (c) 2024 Rylan Malarchick

/**
 * @file Pass.hpp
 * @brief Abstract base class for optimization passes
 */

#pragma once

#include <string>
#include <string_view>

namespace qopt::passes {

class Circuit;  // Forward declaration

/**
 * @brief Abstract base class for circuit optimization passes.
 *
 * Passes transform circuits in place and report whether modifications
 * were made. Inherit from this class to implement custom optimizations.
 */
class Pass {
public:
    virtual ~Pass() noexcept = default;
    
    // Non-copyable, movable
    Pass(const Pass&) = delete;
    Pass& operator=(const Pass&) = delete;
    Pass(Pass&&) noexcept = default;
    Pass& operator=(Pass&&) noexcept = default;
    
    /**
     * @brief Returns the pass name for logging and debugging.
     */
    [[nodiscard]] virtual std::string_view name() const noexcept = 0;
    
    /**
     * @brief Applies the optimization pass to the circuit.
     * @param circuit The circuit to optimize (modified in place)

### Phase 4: Qubit Routing (Weeks 10-13) (lines 221-381)
 */

#pragma once

#include <string>
#include <string_view>

namespace qopt::passes {

class Circuit;  // Forward declaration

/**
 * @brief Abstract base class for circuit optimization passes.
 *
 * Passes transform circuits in place and report whether modifications
 * were made. Inherit from this class to implement custom optimizations.
 */
class Pass {
public:
    virtual ~Pass() noexcept = default;
    
    // Non-copyable, movable
    Pass(const Pass&) = delete;
    Pass& operator=(const Pass&) = delete;
    Pass(Pass&&) noexcept = default;
    Pass& operator=(Pass&&) noexcept = default;
    
    /**
     * @brief Returns the pass name for logging and debugging.
     */
    [[nodiscard]] virtual std::string_view name() const noexcept = 0;
    
    /**
     * @brief Applies the optimization pass to the circuit.
     * @param circuit The circuit to optimize (modified in place)
     * @return true if the circuit was modified
     */
    [[nodiscard]] virtual bool run(ir::Circuit& circuit) = 0;

protected:
    Pass() = default;  // Only constructible via derived classes
};

/**
 * @brief Manages and executes a sequence of optimization passes.
 */
class PassManager {
public:
    PassManager() = default;
    ~PassManager() noexcept = default;
    
    // Move-only (owns passes)
    PassManager(PassManager&&) noexcept = default;
    PassManager& operator=(PassManager&&) noexcept = default;
    PassManager(const PassManager&) = delete;
    PassManager& operator=(const PassManager&) = delete;
    
    /**
     * @brief Adds a pass to the pipeline.
     * @param pass The pass to add (ownership transferred)
     */
    void addPass(std::unique_ptr<Pass> pass);
    
    /**
     * @brief Runs all passes on the circuit.
     * @param circuit The circuit to optimize
     * @return Total number of passes that made modifications
     */
    size_t run(ir::Circuit& circuit);
    
    /**
     * @brief Prints optimization statistics to stdout.
     */
    void printStats() const;

private:
    std::vector<std::unique_ptr<Pass>> passes_;
    
    struct PassStats {
        std::string name;
        size_t runs = 0;
        size_t modifications = 0;
        std::chrono::nanoseconds total_time{0};
    };
    std::vector<PassStats> stats_;
};

}  // namespace qopt::passes
```

### Optimization Passes to Implement

**1. Identity Cancellation Pass**
- X·X = I, H·H = I, Z·Z = I
- CNOT·CNOT = I (same control/target)
- Remove adjacent inverse pairs

**2. Gate Commutation Pass**
- Identify commuting gates (e.g., Rz gates on same qubit commute)
- Reorder to enable more cancellations
- Requires commutation rules database

**3. Rotation Merging Pass**
- Rz(θ₁)·Rz(θ₂) = Rz(θ₁ + θ₂)
- Same for Rx, Ry
- Merge adjacent single-qubit rotations

**4. Two-Qubit Gate Optimization (Stretch)**
- CNOT count reduction
- Template matching for common patterns

### Metrics to Track
- Gates before/after
- Circuit depth before/after
- Two-qubit gate count
- Per-pass statistics

---

## Phase 4: Qubit Routing (Weeks 10-13)

### Goals
- Configurable hardware topology (coupling map)
- Logical → Physical qubit mapping
- SWAP insertion for non-adjacent interactions

### Topology Representation

**Coupling Map (with proper const-correctness and error handling):**
```cpp
// SPDX-License-Identifier: MIT
// Copyright (c) 2024 Rylan Malarchick

/**
 * @file CouplingMap.hpp
 * @brief Hardware topology representation for qubit routing
 */

#pragma once

#include <cstddef>
#include <filesystem>
#include <optional>
#include <span>
#include <utility>
#include <vector>

namespace qopt::routing {

/**
 * @brief Represents the physical qubit connectivity of a quantum device.
 *
 * The coupling map defines which pairs of physical qubits can directly
 * execute two-qubit gates. Used by the Router to insert SWAPs when
 * logical qubits are mapped to non-adjacent physical qubits.
 */
class CouplingMap {
public:
    using Edge = std::pair<size_t, size_t>;
    
    /**

### Technical Decisions (lines 346-482)

### Topology Representation

**Coupling Map (with proper const-correctness and error handling):**
```cpp
// SPDX-License-Identifier: MIT
// Copyright (c) 2024 Rylan Malarchick

/**
 * @file CouplingMap.hpp
 * @brief Hardware topology representation for qubit routing
 */

#pragma once

#include <cstddef>
#include <filesystem>
#include <optional>
#include <span>
#include <utility>
#include <vector>

namespace qopt::routing {

/**
 * @brief Represents the physical qubit connectivity of a quantum device.
 *
 * The coupling map defines which pairs of physical qubits can directly
 * execute two-qubit gates. Used by the Router to insert SWAPs when
 * logical qubits are mapped to non-adjacent physical qubits.
 */
class CouplingMap {
public:
    using Edge = std::pair<size_t, size_t>;
    
    /**
     * @brief Constructs a coupling map with the given edges.
     * @param num_qubits Number of physical qubits
     * @param edges Bidirectional connections between qubits
     * @throws std::invalid_argument if edges reference invalid qubits
     */
    CouplingMap(size_t num_qubits, std::vector<Edge> edges);
    
    // Rule of zero - default special members
    ~CouplingMap() noexcept = default;
    CouplingMap(CouplingMap&&) noexcept = default;
    CouplingMap& operator=(CouplingMap&&) noexcept = default;
    CouplingMap(const CouplingMap&) = default;
    CouplingMap& operator=(const CouplingMap&) = default;
    
    // Queries
    [[nodiscard]] size_t numQubits() const noexcept { return num_qubits_; }
    [[nodiscard]] bool isConnected(size_t q1, size_t q2) const;
    [[nodiscard]] std::span<const size_t> neighbors(size_t qubit) const;
    [[nodiscard]] size_t distance(size_t q1, size_t q2) const;
    [[nodiscard]] std::vector<size_t> shortestPath(size_t from, size_t to) const;
    
    // Factory methods for common topologies
    [[nodiscard]] static CouplingMap linear(size_t n);
    [[nodiscard]] static CouplingMap ring(size_t n);
    [[nodiscard]] static CouplingMap grid(size_t rows, size_t cols);
    [[nodiscard]] static CouplingMap heavyHex(size_t n);  // IBM-style
    [[nodiscard]] static std::optional<CouplingMap> fromFile(
        const std::filesystem::path& path);

private:
    size_t num_qubits_;
    std::vector<Edge> edges_;
    std::vector<std::vector<size_t>> adjacency_;  // adjacency_[q] = neighbors
    mutable std::vector<std::vector<size_t>> distance_cache_;
    
    void buildAdjacencyList();
    void computeDistances() const;
};

}  // namespace qopt::routing
```

### Routing Algorithm

**Basic SWAP-based Router:**
1. Process gates in topological order
2. For each two-qubit gate:
   - Check if qubits are adjacent in coupling map
   - If not, find SWAP path to make them adjacent
   - Insert SWAPs along shortest path
   - Update qubit mapping

**Heuristics to Implement:**
- Greedy: minimize immediate SWAP cost
- Look-ahead: consider future gates when choosing SWAPs
- SABRE-style: forward/backward passes (stretch)

### Metrics to Track
- SWAPs inserted
- Final circuit depth
- Routing time

---

## Phase 5: Output & Polish (Weeks 14-16)

### Goals
- Output optimized OpenQASM
- Statistics and reporting
- Comprehensive test suite
- Documentation

### Output Formats
- [ ] OpenQASM 3.0 (round-trip)
- [ ] Statistics JSON
- [ ] DOT format for DAG visualization (optional)

### Test Suite
- Unit tests for each component (IR, parser, passes, router)
- Integration tests (full pipeline)
- Regression tests with known circuits
- Comparison against Qiskit transpiler (validation)

### Documentation
- README with build instructions and examples
- Architecture overview
- API documentation (Doxygen)
- Example circuits and expected outputs

---

## Technical Decisions

### Language & Build
- **C++17** (modern features, but not bleeding edge)
- **CMake** (standard build system)
- **GoogleTest** for unit testing

### Dependencies (Minimal)
- Standard library only for core functionality
- Optional: nlohmann/json for config/output

### Coding Standards & Best Practices (lines 450-608)
- Statistics and reporting
- Comprehensive test suite
- Documentation

### Output Formats
- [ ] OpenQASM 3.0 (round-trip)
- [ ] Statistics JSON
- [ ] DOT format for DAG visualization (optional)

### Test Suite
- Unit tests for each component (IR, parser, passes, router)
- Integration tests (full pipeline)
- Regression tests with known circuits
- Comparison against Qiskit transpiler (validation)

### Documentation
- README with build instructions and examples
- Architecture overview
- API documentation (Doxygen)
- Example circuits and expected outputs

---

## Technical Decisions

### Language & Build
- **C++17** (modern features, but not bleeding edge)
- **CMake** (standard build system)
- **GoogleTest** for unit testing

### Dependencies (Minimal)
- Standard library only for core functionality
- Optional: nlohmann/json for config/output
- No Qiskit/Cirq dependency (that's the point)

### Design Principles
- LLVM-inspired pass infrastructure
- Clean separation of concerns (IR, parser, passes, routing)
- Testable components
- Performance-conscious but correctness first

---

## Coding Standards & Best Practices

These standards ensure research-grade code quality suitable for PhD applications and open-source contributions. Follow these from day one to avoid technical debt.

### Project Setup Checklist

Before writing any code:
- [ ] MIT License file in repository root
- [ ] Comprehensive `.gitignore` (build/, .cache/, *.o, IDE files)
- [ ] CMake with compiler warnings enabled
- [ ] GoogleTest integration
- [ ] CI/CD pipeline (GitHub Actions)

### License & Copyright

**Every source file** must include an SPDX header:
```cpp
// SPDX-License-Identifier: MIT
// Copyright (c) 2024 Rylan Malarchick
```

Place immediately at the top of the file, before any includes.

### File-Level Documentation

Every header file requires Doxygen documentation:
```cpp
// SPDX-License-Identifier: MIT
// Copyright (c) 2024 Rylan Malarchick

/**
 * @file Gate.hpp
 * @brief Quantum gate representation and gate algebra
 *
 * Provides the Gate class hierarchy representing single-qubit and
 * multi-qubit quantum gates, along with gate composition and
 * commutation utilities.
 *
 * @see Circuit.hpp for circuit-level operations
 * @see DAG.hpp for dependency graph representation
 */
```

### Include Order Convention

Standardize includes in all source files:
```cpp
// SPDX-License-Identifier: MIT
// Copyright (c) 2024 Rylan Malarchick

#include "Gate.hpp"          // 1. Corresponding header (for .cpp files)

#include "Circuit.hpp"       // 2. Project headers (alphabetized)
#include "DAG.hpp"
#include "Qubit.hpp"

#include <algorithm>         // 3. Standard library (alphabetized)
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>
```

Separate each group with a blank line.

### Memory Management: RAII Pattern

**Never use raw `new`/`delete`.** Use smart pointers and RAII wrappers:

```cpp
// BAD - manual memory management
class PassManager {
    Pass* passes_;
    size_t count_;
public:
    PassManager() { passes_ = new Pass[10]; }
    ~PassManager() { delete[] passes_; }  // Easy to forget, exception-unsafe
};

// GOOD - RAII with smart pointers
class PassManager {
    std::vector<std::unique_ptr<Pass>> passes_;
public:
    void addPass(std::unique_ptr<Pass> pass) {
        passes_.push_back(std::move(pass));
    }
    // Destructor automatically cleans up
};
```

**Rule of Zero:** Prefer classes that need no custom destructor, copy, or move operations:
```cpp
class Circuit {
    std::vector<std::unique_ptr<Gate>> gates_;
    std::vector<Qubit> qubits_;
public:
    // No destructor needed - vector and unique_ptr handle cleanup
    Circuit(Circuit&&) noexcept = default;
    Circuit& operator=(Circuit&&) noexcept = default;
    
    // Delete copy to enforce move semantics (circuits can be large)
    Circuit(const Circuit&) = delete;
    Circuit& operator=(const Circuit&) = delete;
};
```

### Exception Safety

**Destructors must be `noexcept`:**
```cpp
class DAGNode {
public:
    ~DAGNode() noexcept = default;  // RAII members handle cleanup safely
};
```


### GoogleTest (lines 577-723)
        passes_.push_back(std::move(pass));
    }
    // Destructor automatically cleans up
};
```

**Rule of Zero:** Prefer classes that need no custom destructor, copy, or move operations:
```cpp
class Circuit {
    std::vector<std::unique_ptr<Gate>> gates_;
    std::vector<Qubit> qubits_;
public:
    // No destructor needed - vector and unique_ptr handle cleanup
    Circuit(Circuit&&) noexcept = default;
    Circuit& operator=(Circuit&&) noexcept = default;
    
    // Delete copy to enforce move semantics (circuits can be large)
    Circuit(const Circuit&) = delete;
    Circuit& operator=(const Circuit&) = delete;
};
```

### Exception Safety

**Destructors must be `noexcept`:**
```cpp
class DAGNode {
public:
    ~DAGNode() noexcept = default;  // RAII members handle cleanup safely
};
```

**Constructor exception safety** - use member initializer lists:
```cpp
// GOOD - exception-safe, no partial construction
Gate::Gate(GateType type, std::vector<int> qubits, double param)
    : type_(type)
    , qubits_(std::move(qubits))  // Move to avoid copy
    , parameter_(param)
{
    validate();  // Throw here if invalid - no cleanup needed
}
```

### Error Handling

Use exceptions for exceptional conditions, return values for expected failures:

```cpp
// For parse errors (expected failures) - return std::optional or error code
std::optional<Circuit> Parser::tryParse(const std::string& input);

// For programming errors - throw exceptions
void Circuit::addGate(std::unique_ptr<Gate> gate) {
    if (!gate) {
        throw std::invalid_argument("Gate cannot be null");
    }
    if (gate->maxQubit() >= num_qubits_) {
        throw std::out_of_range("Gate references qubit beyond circuit size");
    }
    gates_.push_back(std::move(gate));
}
```

### CMake Configuration

Enable all warnings and treat them as errors:
```cmake
cmake_minimum_required(VERSION 3.18)
project(quantum-circuit-optimizer LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Compiler warnings
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(
        -Wall -Wextra -Wpedantic
        -Wshadow -Wconversion -Wsign-conversion
        -Wnon-virtual-dtor -Wold-style-cast
        -Woverloaded-virtual -Wnull-dereference
    )
endif()

# Treat warnings as errors in CI
option(WARNINGS_AS_ERRORS "Treat warnings as errors" OFF)
if(WARNINGS_AS_ERRORS)
    add_compile_options(-Werror)
endif()

# GoogleTest
include(FetchContent)
FetchContent_Declare(
    googletest
    GIT_REPOSITORY https://github.com/google/googletest.git
    GIT_TAG v1.14.0
)
FetchContent_MakeAvailable(googletest)
enable_testing()
```

### Testing Infrastructure

**Test file per component:**
```
tests/
├── ir/
│   ├── test_gate.cpp
│   ├── test_circuit.cpp
│   └── test_dag.cpp
├── parser/
│   ├── test_lexer.cpp
│   └── test_parser.cpp
├── passes/
│   ├── test_cancellation.cpp
│   ├── test_commutation.cpp
│   └── test_merging.cpp
├── routing/
│   ├── test_coupling_map.cpp
│   └── test_router.cpp
└── integration/
    └── test_full_pipeline.cpp
```

**Test naming convention:**
```cpp
TEST(GateTest, HadamardIsHermitian) {
    Gate h = Gate::hadamard(0);
    EXPECT_TRUE(h.isHermitian());
}

TEST(GateTest, CNOTRequiresTwoQubits) {
    EXPECT_THROW(Gate::cnot(0, 0), std::invalid_argument);
}

TEST(CircuitTest, AddGateIncreasesDepth) {
    Circuit c(2);
    EXPECT_EQ(c.depth(), 0);
    c.addGate(Gate::hadamard(0));
    EXPECT_EQ(c.depth(), 1);
}
```

**Run tests with CTest:**
```cmake
add_executable(test_gate tests/ir/test_gate.cpp)

### GoogleTest (lines 695-850)
├── routing/
│   ├── test_coupling_map.cpp
│   └── test_router.cpp
└── integration/
    └── test_full_pipeline.cpp
```

**Test naming convention:**
```cpp
TEST(GateTest, HadamardIsHermitian) {
    Gate h = Gate::hadamard(0);
    EXPECT_TRUE(h.isHermitian());
}

TEST(GateTest, CNOTRequiresTwoQubits) {
    EXPECT_THROW(Gate::cnot(0, 0), std::invalid_argument);
}

TEST(CircuitTest, AddGateIncreasesDepth) {
    Circuit c(2);
    EXPECT_EQ(c.depth(), 0);
    c.addGate(Gate::hadamard(0));
    EXPECT_EQ(c.depth(), 1);
}
```

**Run tests with CTest:**
```cmake
add_executable(test_gate tests/ir/test_gate.cpp)
target_link_libraries(test_gate PRIVATE quantum_ir GTest::gtest_main)
add_test(NAME GateTest COMMAND test_gate)
```

### Code Organization

**One class per header** (with exceptions for tightly coupled types):
```
include/ir/
├── Gate.hpp           # Gate class + GateType enum
├── Qubit.hpp          # Qubit class
├── Circuit.hpp        # Circuit class
├── DAG.hpp            # DAGNode + DAG classes (tightly coupled)
└── Types.hpp          # Common typedefs, constants
```

**Namespace structure:**
```cpp
namespace qopt {          // Top-level namespace
namespace ir {            // IR module
    class Gate { ... };
    class Circuit { ... };
}
namespace parser {
    class Lexer { ... };
    class Parser { ... };
}
namespace passes {
    class Pass { ... };
    class PassManager { ... };
}
namespace routing {
    class CouplingMap { ... };
    class Router { ... };
}
}  // namespace qopt
```

### Const Correctness

Use `const` aggressively:
```cpp
class Circuit {
public:
    // Const member functions for queries
    [[nodiscard]] size_t numQubits() const noexcept { return qubits_.size(); }
    [[nodiscard]] size_t numGates() const noexcept { return gates_.size(); }
    [[nodiscard]] size_t depth() const;
    
    // Non-const for modifications
    void addGate(std::unique_ptr<Gate> gate);
    void removeGate(size_t index);
    
    // Const reference for read-only access
    [[nodiscard]] const Gate& gate(size_t index) const;
};
```

Use `[[nodiscard]]` for functions whose return values should not be ignored.

### Move Semantics

Pass large objects by value and move:
```cpp
// Take ownership via value + move
void Circuit::addGate(std::unique_ptr<Gate> gate) {
    gates_.push_back(std::move(gate));
}

// Return by value (RVO applies)
Circuit Parser::parse(const std::string& source) {
    Circuit circuit(extractNumQubits(source));
    // ... populate circuit ...
    return circuit;  // Moved, not copied
}
```

### Interface Design

**Prefer non-member non-friend functions** for operations that don't need private access:
```cpp
// In Gate.hpp
class Gate { ... };

// Non-member functions in same header
[[nodiscard]] bool commutes(const Gate& a, const Gate& b);
[[nodiscard]] bool areInverse(const Gate& a, const Gate& b);
[[nodiscard]] std::optional<Gate> merge(const Gate& a, const Gate& b);
```

### Documentation Comments

Use Doxygen for public API:
```cpp
/**
 * @brief Applies an optimization pass to the circuit.
 *
 * The pass may modify the circuit in place. Returns true if any
 * modifications were made, false otherwise.
 *
 * @param circuit The circuit to optimize (modified in place)
 * @return true if the circuit was modified
 * @throws std::runtime_error if the pass encounters an internal error
 *
 * @note The circuit must have at least one qubit
 * @see PassManager for running multiple passes
 */
[[nodiscard]] virtual bool run(Circuit& circuit) = 0;
```

### Git Workflow

**Commit message format:**
```
type: short description

Longer description if needed.

- Bullet points for multiple changes
- Keep lines under 72 characters
```

Types: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`, `perf`

**Branch naming:**
- `feature/parser-implementation`
- `fix/dag-cycle-detection`

### Publication Path: End-to-End Quantum Compilation (lines 820-926)
 *
 * The pass may modify the circuit in place. Returns true if any
 * modifications were made, false otherwise.
 *
 * @param circuit The circuit to optimize (modified in place)
 * @return true if the circuit was modified
 * @throws std::runtime_error if the pass encounters an internal error
 *
 * @note The circuit must have at least one qubit
 * @see PassManager for running multiple passes
 */
[[nodiscard]] virtual bool run(Circuit& circuit) = 0;
```

### Git Workflow

**Commit message format:**
```
type: short description

Longer description if needed.

- Bullet points for multiple changes
- Keep lines under 72 characters
```

Types: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`, `perf`

**Branch naming:**
- `feature/parser-implementation`
- `fix/dag-cycle-detection`
- `refactor/pass-infrastructure`

---

## Milestones & Checkpoints

### Milestone 1: "Hello Circuit" (End of Week 2)
- [ ] Project compiles with all warnings enabled
- [ ] MIT license and SPDX headers on all files
- [ ] Can construct a circuit programmatically
- [ ] Can print circuit to stdout
- [ ] Basic unit tests pass (Gate, Circuit, DAG)
- [ ] CI pipeline runs tests on push

### Milestone 2: "Parse It" (End of Week 5)
- [ ] Lexer tokenizes valid OpenQASM
- [ ] Parser builds AST
- [ ] AST converts to Circuit IR
- [ ] Can parse and print back simple circuits

### Milestone 3: "Optimize It" (End of Week 9)
- [ ] Pass manager infrastructure works
- [ ] At least 3 optimization passes implemented
- [ ] Measurable gate reduction on test circuits
- [ ] Before/after statistics

### Milestone 4: "Route It" (End of Week 13)
- [ ] Coupling map representation works
- [ ] Basic routing algorithm implemented
- [ ] SWAP insertion correct
- [ ] Works on linear, grid topologies

### Milestone 5: "Ship It" (End of Week 16)
- [ ] Full pipeline working end-to-end
- [ ] Comprehensive test suite
- [ ] Clean documentation
- [ ] GitHub repo polished

---

## Interview Talking Points

1. **"Why build your own instead of using Qiskit/TKET?"**
   - "I wanted to understand compiler infrastructure from the ground up. Just like my LLVM pass taught me about classical optimization, this taught me about quantum-specific transformations. Using an existing framework would hide the interesting parts."

2. **"Walk me through your IR design."**
   - "I use a DAG representation where nodes are gates and edges represent qubit dependencies. This makes topological traversal natural and enables efficient pattern matching for optimization. Similar to how LLVM uses SSA for data flow, the DAG makes gate dependencies explicit."

3. **"How does your routing algorithm work?"**
   - "I implemented a greedy SWAP-based router with configurable coupling maps. For each non-local two-qubit gate, I find the shortest SWAP path and insert the necessary operations. The topology is configurable - I support linear chains, grids, and IBM-style heavy-hex."

4. **"What was the hardest part?"**
   - "Gate commutation for optimization. You need to know which gates commute (Rz gates, diagonal gates, etc.) and leverage that to expose more cancellation opportunities. Getting the commutation rules right required careful thought about the linear algebra."

---

## References

- [OpenQASM 3.0 Specification](https://openqasm.com/)
- [Qiskit Transpiler Source](https://github.com/Qiskit/qiskit/tree/main/qiskit/transpiler) (for comparison)
- [TKET Paper](https://arxiv.org/abs/2003.10611) (routing algorithms)
- [SABRE Paper](https://arxiv.org/abs/1809.02573) (SWAP-based routing)
- [LLVM Pass Infrastructure](https://llvm.org/docs/WritingAnLLVMPass.html) (inspiration)

---

## Publication Path: End-to-End Quantum Compilation

### The Opportunity

The quantum circuit optimizer alone is **infrastructure** - valuable for your skills and portfolio, but not novel research. However, combined with QubitPulseOpt, you have a unique angle that nobody else has.

### Proposed Paper

**Title:** "End-to-End Quantum Compilation: From Circuit Optimization to Pulse-Level Control"


### Publication Path: End-to-End Quantum Compilation (lines 910-1015)
- [Qiskit Transpiler Source](https://github.com/Qiskit/qiskit/tree/main/qiskit/transpiler) (for comparison)
- [TKET Paper](https://arxiv.org/abs/2003.10611) (routing algorithms)
- [SABRE Paper](https://arxiv.org/abs/1809.02573) (SWAP-based routing)
- [LLVM Pass Infrastructure](https://llvm.org/docs/WritingAnLLVMPass.html) (inspiration)

---

## Publication Path: End-to-End Quantum Compilation

### The Opportunity

The quantum circuit optimizer alone is **infrastructure** - valuable for your skills and portfolio, but not novel research. However, combined with QubitPulseOpt, you have a unique angle that nobody else has.

### Proposed Paper

**Title:** "End-to-End Quantum Compilation: From Circuit Optimization to Pulse-Level Control"

**Core Contribution:**
A complete, open-source quantum compilation pipeline that takes high-level circuits, optimizes them, routes to hardware topology, and generates noise-robust control pulses - with end-to-end fidelity analysis.

### Why This Is Publishable

1. **Integration novelty** - Existing tools stop at gate level (Qiskit, TKET) or start at pulse level (Qiskit Pulse, your QubitPulseOpt). Nobody has a clean, documented end-to-end pipeline with fidelity analysis at each stage.

2. **Cross-layer optimization** - You can explore questions like: "Does gate-level optimization actually improve pulse-level fidelity?" or "Can pulse-aware decomposition outperform standard decomposition?"

3. **Reproducibility contribution** - A clean C++ implementation with Python bindings, fully open-source, is valuable to the community.

### Paper Structure (Draft)

```
1. Introduction
   - Gap between circuit-level and pulse-level compilation
   - Need for end-to-end fidelity analysis

2. Background
   - Quantum circuit optimization (gate cancellation, routing)
   - Optimal control for quantum gates (GRAPE, your QubitPulseOpt work)

3. System Architecture
   - Circuit optimizer (this project)
   - Integration layer (circuit → pulse specification)
   - Pulse optimizer (QubitPulseOpt)

4. Cross-Layer Analysis
   - Fidelity at each compilation stage
   - Where do errors accumulate?
   - Does circuit optimization help pulse fidelity?

5. Experiments
   - VQE circuits (you have these from QuantumVQE!)
   - Random circuits / QV benchmarks
   - Different hardware topologies

6. Results
   - End-to-end fidelity comparison
   - Compilation time breakdown
   - Optimization effectiveness

7. Conclusion
   - Open-source contribution
   - Future: hardware validation on IQM
```

### Research Questions to Explore

1. **Does circuit depth reduction translate to better pulse fidelity?**
   - Fewer gates = fewer pulses = less decoherence time
   - But: aggressive optimization might create harder-to-implement gates

2. **Pulse-aware gate decomposition:**
   - Standard: decompose to {CNOT, single-qubit}
   - Novel: decompose to gates that YOUR pulse optimizer handles best
   - This is a genuine research contribution

3. **Routing for pulse fidelity:**
   - Standard routing minimizes SWAP count
   - Novel: route to minimize estimated pulse infidelity (use your QubitPulseOpt fidelity predictions)

4. **Noise-aware compilation:**
   - Use T1/T2 from hardware (you have IQM parameters)
   - Route away from noisy qubits
   - Prioritize faster gates on qubits with short coherence

### Timeline for Publication

| Phase | Work | Timeline |
|-------|------|----------|
| 1 | Build circuit optimizer (this guide) | Weeks 1-16 |
| 2 | Integration layer (circuit → QubitPulseOpt) | Weeks 17-20 |
| 3 | End-to-end benchmarking | Weeks 21-24 |
| 4 | Novel contribution (pick one research question) | Weeks 25-30 |
| 5 | Paper writing | Weeks 31-34 |
| 6 | Submission & revision | Weeks 35+ |

**Target venues:**
- arXiv preprint (immediate visibility)
- IEEE QCE (Quantum Computing & Engineering)
- ACM/IEEE MICRO or ASPLOS (systems angle)
- Quantum Science and Technology (if strong physics contribution)
- PRA/PRX Quantum (if strong theoretical contribution)

### Integration Architecture

```
┌─────────────────────────────────────────────────────────────────┐

### Next Steps (lines 997-1099)
|-------|------|----------|
| 1 | Build circuit optimizer (this guide) | Weeks 1-16 |
| 2 | Integration layer (circuit → QubitPulseOpt) | Weeks 17-20 |
| 3 | End-to-end benchmarking | Weeks 21-24 |
| 4 | Novel contribution (pick one research question) | Weeks 25-30 |
| 5 | Paper writing | Weeks 31-34 |
| 6 | Submission & revision | Weeks 35+ |

**Target venues:**
- arXiv preprint (immediate visibility)
- IEEE QCE (Quantum Computing & Engineering)
- ACM/IEEE MICRO or ASPLOS (systems angle)
- Quantum Science and Technology (if strong physics contribution)
- PRA/PRX Quantum (if strong theoretical contribution)

### Integration Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    End-to-End Pipeline                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OpenQASM 3.0                                                   │
│       ↓                                                         │
│  ┌──────────────────────────────┐                              │
│  │  quantum-circuit-optimizer   │  ← THIS PROJECT              │
│  │  - Parse                     │                              │
│  │  - Optimize                  │                              │
│  │  - Route                     │                              │
│  └──────────────────────────────┘                              │
│       ↓                                                         │
│  ┌──────────────────────────────┐                              │
│  │  Integration Layer           │  ← NEW (Python, bridges both)│
│  │  - Gate → Pulse spec         │                              │
│  │  - Hardware parameters       │                              │
│  └──────────────────────────────┘                              │
│       ↓                                                         │
│  ┌──────────────────────────────┐                              │
│  │  QubitPulseOpt               │  ← YOUR EXISTING WORK        │
│  │  - GRAPE optimization        │                              │
│  │  - Noise-robust pulses       │                              │
│  └──────────────────────────────┘                              │
│       ↓                                                         │
│  Pulse Sequence + Fidelity Estimate                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Minimum Viable Paper

If time is tight, the minimum publishable unit is:

1. Working circuit optimizer (doesn't need all features)
2. Integration with QubitPulseOpt
3. End-to-end fidelity analysis on VQE circuits
4. One novel insight (e.g., "circuit depth reduction of X% yields pulse fidelity improvement of Y%")

This could be a **workshop paper** or **short paper** at QCE, then expanded later.

### What Makes This Your Unique Angle

- You built QubitPulseOpt (pulse-level expertise)
- You built the circuit optimizer (gate-level expertise)
- You have VQE circuits from real research (application expertise)
- You have IQM hardware parameters (hardware connection)

Nobody else has this exact combination. That's your publication angle.

---

## Next Steps

### Day 1: Project Foundation
1. Create GitHub repo `quantum-circuit-optimizer`
2. Add MIT LICENSE file
3. Create `.gitignore` (build/, .cache/, *.o, IDE files, etc.)
4. Set up CMake with:
   - C++17 standard
   - All compiler warnings enabled
   - GoogleTest via FetchContent
   - `compile_commands.json` export
5. Create initial directory structure (include/, src/, tests/)
6. Add GitHub Actions CI workflow for build + test

### Day 2-3: Core IR
7. Implement `Types.hpp` (common typedefs, constants)
8. Implement `Gate.hpp/cpp` with:
   - SPDX header + file-level Doxygen
   - GateType enum
   - Gate class with RAII semantics
   - Unit tests (`test_gate.cpp`)
9. Implement `Circuit.hpp/cpp` with unit tests
10. Implement `DAG.hpp/cpp` with unit tests

### Week 2: Parser Foundation
11. Implement `Token.hpp` and `Lexer.hpp/cpp`
12. Write lexer unit tests first (TDD)
13. Implement `AST.hpp` and `Parser.hpp/cpp`
14. Parse simple circuits and verify round-trip

---

*This project directly supports PhD applications in quantum compilers and demonstrates the ability to build real compiler infrastructure from scratch with research-grade code quality.*

## Source: sprint-1a-foundation.md
*Sprint 1a foundation details*

### Tasks (lines 1-117)
# Sprint 1A: Foundation

**Goal:** Working build, basic IR, first tests passing, CI/CD running  
**Duration:** 3-5 coding sessions  
**Exit Criteria:** `cmake --build build && ctest` passes with ≥10 unit tests

---

## Current State

| Component | Status | Issues |
|-----------|--------|--------|
| CMakeLists.txt | Broken | No warnings, no GoogleTest, minimal config |
| Gate.hpp | Partial | No constructors, no validation, no operators |
| Circuit.hpp | Partial | No iteration, missing methods main.cpp expects |
| Qubit.hpp | Empty | 1-line stub |
| DAG.hpp | Empty | 1-line stub (deferred to Sprint 1B) |
| main.cpp | Broken | Uses non-existent constructors/methods |
| Tests | None | Empty directories |
| CI/CD | None | No GitHub Actions |

---

## Tasks

### Task 1: CMakeLists.txt Overhaul
**Priority:** Critical (blocks everything)

Rewrite CMakeLists.txt with:
- [x] cmake_minimum_required(VERSION 3.18)
- [x] C++17 standard required
- [x] Compiler warnings (-Wall -Wextra -Wpedantic -Wshadow -Wconversion)
- [x] WARNINGS_AS_ERRORS option for CI
- [x] GoogleTest via FetchContent
- [x] Library target (qopt_ir) for testability
- [x] compile_commands.json export
- [x] CTest integration

**Acceptance:** `cmake -B build && cmake --build build` completes with zero warnings

---

### Task 2: Types.hpp (New File)
**Priority:** High

Create `include/ir/Types.hpp` with:
- [x] SPDX header + copyright
- [x] Common type aliases (QubitIndex, GateId, Angle)
- [x] Constants (MAX_QUBITS, TOLERANCE)
- [x] Namespace structure (qopt::ir)

**Acceptance:** Types compile and are used by other headers

---

### Task 3: Gate.hpp Rewrite
**Priority:** High

Complete rewrite with:
- [x] SPDX header + Doxygen file-level docs
- [x] Namespace qopt::ir
- [x] GateType enum with all common gates (H, X, Y, Z, S, T, CNOT, CZ, Rx, Ry, Rz, SWAP)
- [x] Gate class with:
  - Proper constructor(s)
  - Factory methods: Gate::h(qubit), Gate::cnot(control, target), Gate::rz(qubit, angle)
  - Accessors: type(), qubits(), parameter(), numQubits(), isParameterized()
  - Validation: throws on invalid qubit indices
  - [[nodiscard]] attributes
  - operator== for comparison
- [x] Non-member functions: gateTypeName(GateType), isHermitian(GateType), numQubitsFor(GateType)

**Acceptance:** Unit tests for all Gate operations pass

---

### Task 4: Qubit.hpp Implementation
**Priority:** Medium

Create `include/ir/Qubit.hpp` with:
- [x] SPDX header + Doxygen
- [x] Namespace qopt::ir
- [x] QubitId type (size_t alias)
- [x] Qubit class (simple wrapper, may just be typedef for now)

**Acceptance:** Compiles and integrates with Gate/Circuit

---

### Task 5: Circuit.hpp Rewrite
**Priority:** High

Complete rewrite with:
- [x] SPDX header + Doxygen
- [x] Namespace qopt::ir
- [x] Circuit class with:
  - Constructor: Circuit(size_t num_qubits)
  - Gate management: addGate(Gate), gates(), gate(index), numGates()
  - Qubit info: numQubits()
  - Metrics: depth() (longest path through circuit)
  - Iteration: begin(), end() for range-for
  - Validation: throws if gate references invalid qubit
  - Move semantics (delete copy for large circuits)
- [x] operator<< for printing

**Acceptance:** Unit tests for Circuit operations pass, can iterate with range-for

---

### Task 6: main.cpp Fix
**Priority:** Medium

Rewrite to use actual API:
- [x] Use factory methods: Gate::h(), Gate::cnot()
- [x] Use proper addGate() calls
- [x] Print circuit with operator<<
- [x] Demonstrate basic operations


### Code Standards Checklist (lines 95-234)
- [x] Circuit class with:
  - Constructor: Circuit(size_t num_qubits)
  - Gate management: addGate(Gate), gates(), gate(index), numGates()
  - Qubit info: numQubits()
  - Metrics: depth() (longest path through circuit)
  - Iteration: begin(), end() for range-for
  - Validation: throws if gate references invalid qubit
  - Move semantics (delete copy for large circuits)
- [x] operator<< for printing

**Acceptance:** Unit tests for Circuit operations pass, can iterate with range-for

---

### Task 6: main.cpp Fix
**Priority:** Medium

Rewrite to use actual API:
- [x] Use factory methods: Gate::h(), Gate::cnot()
- [x] Use proper addGate() calls
- [x] Print circuit with operator<<
- [x] Demonstrate basic operations

**Acceptance:** main.cpp compiles and runs, produces sensible output

---

### Task 7: Unit Tests - Gate
**Priority:** High

Create `tests/ir/test_gate.cpp` with:
- [x] Test fixture setup
- [x] Factory method tests (h, x, cnot, rz create correct gates)
- [x] Accessor tests (type, qubits, parameter)
- [x] Validation tests (invalid qubit throws)
- [x] Equality tests
- [x] Parameterized gate tests (Rz with angle)
- [x] Edge cases (single qubit, two qubit, parametric)

**Acceptance:** ≥6 tests, all pass

---

### Task 8: Unit Tests - Circuit
**Priority:** High

Create `tests/ir/test_circuit.cpp` with:
- [x] Construction tests (empty circuit, with qubits)
- [x] addGate tests (single, multiple)
- [x] Validation tests (gate with invalid qubit throws)
- [x] Iteration tests (range-for works)
- [x] Depth calculation tests
- [x] numGates/numQubits tests

**Acceptance:** ≥6 tests, all pass

---

### Task 9: GitHub Actions CI
**Priority:** Medium

Create `.github/workflows/ci.yml` with:
- [x] Trigger on push/PR to main
- [x] Ubuntu latest
- [x] CMake configure with WARNINGS_AS_ERRORS=ON
- [x] Build
- [x] Run tests with ctest
- [x] Upload test results

**Acceptance:** CI badge shows green on push

---

### Task 10: README Update
**Priority:** Low

Update README.md with:
- [x] Project description
- [x] Build instructions
- [x] Test instructions
- [x] Current status
- [x] Project structure

**Acceptance:** README accurately reflects project state

---

## File Changes Summary

### New Files
```
include/ir/Types.hpp           # Type aliases and constants
tests/ir/test_gate.cpp         # Gate unit tests
tests/ir/test_circuit.cpp      # Circuit unit tests
.github/workflows/ci.yml       # CI pipeline
docs/sprint-1a-foundation.md   # This file
```

### Modified Files
```
CMakeLists.txt                 # Complete rewrite
include/ir/Gate.hpp            # Complete rewrite
include/ir/Qubit.hpp           # Implement (currently empty)
include/ir/Circuit.hpp         # Complete rewrite
src/main.cpp                   # Fix to use actual API
README.md                      # Update with build/test instructions
```

### Unchanged (Deferred)
```
include/ir/DAG.hpp             # Sprint 1B
include/parser/Parser.hpp      # Sprint 2
include/passes/Pass.hpp        # Sprint 3
include/routing/Router.hpp     # Sprint 4
```

---

## Implementation Order

```
1. CMakeLists.txt      ← Must be first (enables compilation)
2. Types.hpp           ← Dependencies for other headers
3. Gate.hpp            ← Core type, needed by Circuit
4. Qubit.hpp           ← Simple, quick win
5. Circuit.hpp         ← Uses Gate, enables main.cpp
6. main.cpp            ← Validates API works
7. test_gate.cpp       ← Validates Gate implementation
8. test_circuit.cpp    ← Validates Circuit implementation
9. ci.yml              ← Automation
10. README.md          ← Documentation
```

---

## Code Standards Checklist

For each file, verify:

- [ ] SPDX-License-Identifier: MIT header

### Notes (lines 206-287)
include/parser/Parser.hpp      # Sprint 2
include/passes/Pass.hpp        # Sprint 3
include/routing/Router.hpp     # Sprint 4
```

---

## Implementation Order

```
1. CMakeLists.txt      ← Must be first (enables compilation)
2. Types.hpp           ← Dependencies for other headers
3. Gate.hpp            ← Core type, needed by Circuit
4. Qubit.hpp           ← Simple, quick win
5. Circuit.hpp         ← Uses Gate, enables main.cpp
6. main.cpp            ← Validates API works
7. test_gate.cpp       ← Validates Gate implementation
8. test_circuit.cpp    ← Validates Circuit implementation
9. ci.yml              ← Automation
10. README.md          ← Documentation
```

---

## Code Standards Checklist

For each file, verify:

- [ ] SPDX-License-Identifier: MIT header
- [ ] Copyright line
- [ ] File-level Doxygen documentation
- [ ] Namespace qopt::ir (or qopt::*)
- [ ] Include guards using #pragma once
- [ ] Includes ordered: corresponding header, project headers, std headers
- [ ] [[nodiscard]] on query functions
- [ ] noexcept on destructors and simple accessors
- [ ] const correctness
- [ ] Input validation with descriptive exceptions
- [ ] No raw new/delete

---

## Validation Commands

```bash
# Configure (from project root)
cmake -B build -DCMAKE_BUILD_TYPE=Debug -DWARNINGS_AS_ERRORS=ON

# Build
cmake --build build -j$(nproc)

# Run tests
cd build && ctest --output-on-failure

# Run main
./build/quantum_circuit_optimizer

# Check for warnings (should be zero)
cmake --build build 2>&1 | grep -i warning
```

---

## Exit Criteria Checklist

- [ ] `cmake -B build` succeeds
- [ ] `cmake --build build` succeeds with zero warnings
- [ ] `ctest` runs ≥10 tests, all pass
- [ ] `./quantum_circuit_optimizer` produces sensible output
- [ ] CI pipeline passes on GitHub
- [ ] All source files have SPDX headers
- [ ] README has build/test instructions

---

## Notes

- DAG.hpp is deferred to Sprint 1B (not needed for basic IR)
- Parser, Passes, Routing are deferred to later sprints
- Focus is on getting a solid, tested foundation
- Apply coding standards from docs/ consistently

